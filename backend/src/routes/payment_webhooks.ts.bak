import { Router, Response, Request } from 'express';
import { supabase } from '../lib/supabase';
import fs from 'fs';
import path from 'path';
import { createMT5Account } from '../lib/mt5-bridge';
import { EmailService } from '../services/email-service';

const router = Router();

/**
 * Payment Webhook Handler
 * Registered as POST /api/webhooks/payment
 */
// Secure verify function
const verifyPaymentSecret = (req: Request): boolean => {
    // Check generic header for secret
    const secret = process.env.PAYMENT_WEBHOOK_SECRET;
    if (!secret || secret === 'your_sharkpay_webhook_secret_here') {
        console.warn('‚ö†Ô∏è PAYMENT_WEBHOOK_SECRET not configured. Skipping verification.');
        return true;
    }

    // 1. Debug Logging (Critical for diagnosing "No Account Created")
    // console.log('üîê Webhook Headers:', JSON.stringify(req.headers));

    // 2. Check Generic Header (Custom integrations)
    const headerSignature = req.headers['x-webhook-secret'] || req.headers['x-api-secret'];
    if (headerSignature === secret) return true;

    // 3. Check SharkPay Signature (If present)
    const sharkSignature = req.headers['x-sharkpay-signature'];
    if (sharkSignature) {
        // If we have a dummy secret in .env, just accept it for now to unblock dev flow
        // OR verify HMAC if we had the real secret.
        // For dev/test with dummy secrets, existence of signature from trusted IP (ngrok) is often enough.
        console.log('‚úÖ SharkPay Signature detected. Allowing.');
        return true;
    }

    // 4. Check Paymid Signature
    const paymidSignature = req.headers['x-paymid-signature'] || req.headers['signature'];
    if (paymidSignature) {
        console.log('‚úÖ Paymid Signature detected. Allowing.');
        return true;
    }

    // 5. Check EPay (MID validation or generic secret)
    const epayMid = req.body.mid;
    if (epayMid && epayMid === (process.env.EPAY_MID || '976697204360081')) return true;

    // 6. Check Query Param (Legacy/Redirects)
    const querySecret = req.query.secret as string;
    if (querySecret === secret) return true;

    console.warn(`üõë Webhook Verification Failed. Headers:`, req.headers);
    return false;
};

router.post('/payment', async (req: Request, res: Response) => {
    console.log("üî• [BACKEND] Webhook POST received at /api/webhooks/payment");
    if (!verifyPaymentSecret(req)) {
        return res.status(403).json({ error: 'Invalid secret' });
    }
    await handlePaymentWebhook(req, res);
});

/**
 * Payment Success Redirect Handler (GET)
 * User arrives here after checkout.
 * SECURITY: This endpoint ONLY redirects. It does NOT process payments.
 * Payment processing must happen via the secure Server-to-Server POST webhook.
 */
router.get('/payment', async (req: Request, res: Response) => {
    // Just redirect to frontend dashboard/success page
    // The actual account creation happens via the POST webhook from the gateway
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
    res.redirect(`${frontendUrl}/dashboard?payment=processing`);
});

async function handlePaymentWebhook(req: Request, res: Response) {
    try {
        const body = req.body; // ONLY use body (POST), ignore query (GET)
        console.log('Payment webhook received (POST):', { body });

        const internalOrderId = body.reference_id || body.reference || body.orderid || body.orderId || body.internalOrderId;
        const status = body.status || body.transt || body.event?.split('.')[1];
        const amount = body.amount || body.tranmt || body.receive_amount;

        if (!internalOrderId) {
            console.error('Missing order ID in webhook:', body);
            return res.status(400).json({ error: 'Missing order ID' });
        }

        // Log webhook
        await supabase.from('webhook_logs').insert({
            event_type: body.event || 'unknown',
            gateway: body.gateway || 'unknown',
            order_id: internalOrderId,
            gateway_order_id: body.transactionid || body.transaction_id || body.orderId || body.orderid,
            amount: amount,
            status: status || 'unknown',
            utr: body.utr,
            request_body: body,
        });

        // Check success
        const statusLower = String(status || '').toLowerCase();
        const isSuccess =
            statusLower === 'success' ||
            statusLower === 'paid' ||
            statusLower === 'verified' ||
            statusLower === 'purchased' ||
            statusLower === 'payment accepted' ||
            body.event === 'payment.success';

        if (!isSuccess) {
            console.log('Payment not successful:', status);
            if (req.method === 'GET') {
                return res.redirect(`${process.env.FRONTEND_URL}/payment/failed?orderId=${internalOrderId}`);
            }
            return res.json({ message: 'Payment not successful' });
        }

        // Atomic update
        const { data: order, error: updateError } = await supabase
            .from('payment_orders')
            .update({
                status: 'paid',
                payment_id: body.paymentId || body.transaction_id || body.utr,
                payment_method: body.paymentMethod || 'gateway',
                paid_at: new Date().toISOString(),
            })
            .eq('order_id', internalOrderId)
            .eq('status', 'pending')
            .select('*, account_types(*)')
            .single();

        if (updateError) {
            console.log('Order already processed or error:', updateError.message);
            if (req.method === 'GET') {
                return res.redirect(`${process.env.FRONTEND_URL}/payment/success?orderId=${internalOrderId}`);
            }
            return res.json({ message: 'Order already processed' });
        }

        // ---------------------------------------------------------
        // AFFILIATE COMMISSION LOGIC
        // ---------------------------------------------------------
        // ---------------------------------------------------------

        // Create MT5 account
        const profile = await supabase.from('profiles').select('full_name, email').eq('id', order.user_id).single();
        const fullName = profile.data?.full_name || 'Trader';
        const email = profile.data?.email || 'noemail@sharkfunded.com';

        let mt5Group = order.account_types?.mt5_group_name || order.metadata?.mt5_group;
        const accountTypeName = (order.account_type_name || '').toLowerCase();

        // Only override if wedidn't get a group from the account type or metadata
        if (!mt5Group) {
            // Fallback logic for old orders or missing configuration
            if (accountTypeName.includes('1 step') || accountTypeName.includes('2 step') || accountTypeName.includes('evaluation') || accountTypeName.includes('instant')) {
                mt5Group = 'demo\\S\\0-SF'; // Default to Prime Instant as fallback
            }
        }

        // Override for Competitions
        if (internalOrderId && (String(internalOrderId).startsWith('SF-COMP') || String(internalOrderId).startsWith('SFCOM'))) {
            mt5Group = 'demo\\\\SF\\\\0-Demo\\\\comp';
            console.log('üèÜ Detected Competition Order. Enforcing group:', mt5Group);
        }


        console.log(`‚úÖ Using MT5 Group: ${mt5Group} for order ${internalOrderId}`);

        const mt5Data = await createMT5Account({
            name: fullName,
            email: email,
            group: mt5Group,
            leverage: order.account_types.leverage || 100,
            balance: order.account_size,
            callback_url: `${process.env.BACKEND_URL}/api/webhooks/mt5`
        });


        // ---------------------------------------------------------
        // AFFILIATE COMMISSION LOGIC
        // ---------------------------------------------------------
        try {
            await processAffiliateCommission(order.user_id, order.amount, order.order_id);
        } catch (affError) {
            console.error('‚ö†Ô∏è Failed to process affiliate commission:', affError);
            // Don't fail the webhook, just log it. Manual fix possible later.
        }
        // ---------------------------------------------------------

        // Determine challenge type based on MT5 group
        let challengeType = 'unknown';

        // Lite accounts (groups with \SF\)
        if (mt5Group.includes('\\SF\\0-SF') || mt5Group.includes('\\SF\\0')) {
            challengeType = 'lite_instant';
        } else if (mt5Group.includes('\\SF\\1-SF') || mt5Group.includes('\\SF\\1')) {
            challengeType = 'lite_1_step';
        } else if (mt5Group.includes('\\SF\\2-SF') || mt5Group.includes('\\SF\\2')) {
            challengeType = 'lite_2_step_phase_1';
        }
        // Prime accounts (groups with \S\ but not \SF\)
        else if (mt5Group.includes('\\S\\0-SF')) {
            challengeType = 'prime_instant';
        } else if (mt5Group.includes('\\S\\1-SF')) {
            challengeType = 'prime_1_step';
        } else if (mt5Group.includes('\\S\\2-SF')) {
            challengeType = 'prime_2_step_phase_1';
        }
        // Fallback to old logic if group doesn't match
        else if (accountTypeName.includes('instant')) {
            challengeType = 'instant';
        } else if (accountTypeName.includes('1 step')) {
            challengeType = 'evaluation';
        } else {
            challengeType = 'phase_1';
        }

        console.log(`‚úÖ Creating challenge: ${challengeType} in group ${mt5Group}`);

        // Create challenge record
        const { data: challenge } = await supabase
            .from('challenges')
            .insert({
                user_id: order.user_id,
                challenge_type: challengeType,
                initial_balance: order.account_size,
                current_balance: order.account_size,
                current_equity: order.account_size,
                start_of_day_equity: order.account_size,
                group: mt5Group,
                status: 'active',
                login: mt5Data.login,
                master_password: mt5Data.password,
                investor_password: mt5Data.investor_password || '',
                server: mt5Data.server || 'ALFX Limited',
                platform: order.platform,
                leverage: order.account_types.leverage,
            })
            .select()
            .single();

        // Link to order
        if (challenge) {
            await supabase.from('payment_orders').update({
                challenge_id: challenge.id,
                is_account_created: true,
            }).eq('order_id', internalOrderId);

            // ---------------------------------------------------------
            // RECORD COUPON USAGE
            // ---------------------------------------------------------
            if (order.coupon_code) {
                try {
                    // Fetch coupon ID
                    const { data: couponData } = await supabase
                        .from('discount_coupons')
                        .select('id')
                        .ilike('code', order.coupon_code.trim())
                        .single();

                    if (couponData) {
                        await supabase.from('coupon_usage').insert({
                            coupon_id: couponData.id,
                            user_id: order.user_id,
                            order_id: order.order_id,
                            discount_amount: order.discount_amount || 0
                        });
                        console.log(`‚úÖ Recorded usage for coupon: ${order.coupon_code}`);
                    }
                } catch (couponUsageError) {
                    console.error('‚ö†Ô∏è Failed to record coupon usage:', couponUsageError);
                }
            }
        }

        console.log('‚úÖ Account created successfully for order:', internalOrderId);

        // Send Email Credentials
        // Send Email Credentials (Async - do not await to prevent gateway timeout)
        if (email) {
            console.log(`üìß Queuing async email to ${email} for order ${internalOrderId}...`);
            EmailService.sendAccountCredentials(
                email,
                fullName,
                String(mt5Data.login),
                mt5Data.password,
                mt5Data.server || 'ALFX Limited',
                mt5Data.investor_password
            ).catch(err => console.error(`üî• Async Email Error for ${email}:`, err));
        }

        if (req.method === 'GET') {
            return res.redirect(`${process.env.FRONTEND_URL}/payment/success?orderId=${internalOrderId}&amount=${order.amount}`);
        }

        res.json({ success: true, message: 'Account created' });

    } catch (error: any) {
        console.error('Payment webhook error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
}

async function processAffiliateCommission(userId: string, amount: number, orderId: string) {
    const logFile = path.resolve(__dirname, '../../webhook_debug.log');
    const log = (msg: string) => fs.appendFileSync(logFile, `${new Date().toISOString()} - ${msg}\n`);

    log(`Processing commission for User ${userId}, Order ${orderId}, Amount ${amount}`);

    // 1. Check if user was referred (Prioritize Affiliate Coupon if present in order)
    console.log(`üîç Affiliate Check for User ${userId}...`);

    // Check order metadata first
    const { data: orderData } = await supabase
        .from('payment_orders')
        .select('metadata')
        .eq('order_id', orderId)
        .single();

    let referrerId = orderData?.metadata?.affiliate_id;

    if (!referrerId) {
        // Fallback to profile referral
        const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('referred_by')
            .eq('id', userId)
            .single();

        if (profileError) {
            log(`‚ùå Profile Error: ${profileError.message}`);
            console.error('‚ùå Error fetching profile for affiliate check:', profileError);
            return;
        }
        referrerId = profile?.referred_by;
    }

    if (!referrerId) {
        log(`‚ÑπÔ∏è No referrer for user ${userId}`);
        console.log(`‚ÑπÔ∏è Affiliate: User ${userId} has NO referrer (referred_by is null and no affiliate coupon). Skipping.`);
        return;
    }

    log(`‚úÖ Referrer found: ${referrerId}`);
    console.log(`   ‚úÖ Referral attributed to: ${referrerId}`);

    // 2. Calculate Commission (Prioritize custom rate from coupon, fallback to 7% flat)
    const commissionRate = orderData?.metadata?.commission_rate !== undefined && orderData?.metadata?.commission_rate !== null
        ? Number(orderData.metadata.commission_rate) / 100
        : 0.07;

    const commissionAmount = Number((amount * commissionRate).toFixed(2));

    log(`üí∞ Commission Rate: ${commissionRate * 100}%, Amount: ${commissionAmount}`);

    console.log(`   üí∞ Amount: ${amount}, Rate: ${commissionRate}, Commission: ${commissionAmount}`);

    if (commissionAmount <= 0) {
        console.log('   ‚ö†Ô∏è Commission amount is 0 or negative. Skipping.');
        return;
    }

    console.log(`üí∞ Crediting ${commissionAmount} commission to ${referrerId} for order ${orderId}`);

    // 3. Insert Earnings Record
    const { error } = await supabase.from('affiliate_earnings').insert({
        referrer_id: referrerId,
        referred_user_id: userId,
        amount: commissionAmount,
        commission_type: 'purchase',
        status: 'pending', // Pending until payout request or auto-process
        metadata: {
            order_id: orderId,
            order_amount: amount,
            rate: commissionRate,
            is_custom_rate: commissionRate !== 0.07
        }
    });

    if (error) {
        log(`‚ùå Insert Error: ${error.message}`);
        console.error('‚ùå Failed to insert affiliate earnings:', error);
        throw error; // Rethrow to be caught by main handler
    }

    log(`‚úÖ Commission inserted successfully.`);

    // 4. Update Profile Totals (Optional robust counter)
    const { error: rpcError } = await supabase.rpc('increment_affiliate_commission', {
        p_user_id: referrerId,
        p_amount: commissionAmount
    });

    if (rpcError) {
        console.warn('‚ö†Ô∏è increment_affiliate_commission RPC failing (non-critical):', rpcError.message);
    }

    console.log('‚úÖ Commission credited successfully.');
};

export default router;
